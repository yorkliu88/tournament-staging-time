<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Tournament Staging Time & Players</title>

<style>
  :root { --bg:#fafafa; --card:#fff; --ink:#111; --muted:#666; --ok:#0b7c3e; --warn:#c62828; --line:#eaeaea; }
  body { margin:0; font:16px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; background:var(--bg); color:var(--ink); }
  .wrap { max-width:1100px; margin:0 auto; padding:24px; }
  .row { display:grid; gap:16px; grid-template-columns: 1fr; }
  @media(min-width: 860px){ .row{ grid-template-columns: 1fr 1fr; } }
  .card { background:var(--card); border:1px solid var(--line); border-radius:14px; box-shadow:0 1px 2px rgba(0,0,0,.04); }
  .pad { padding:16px 18px; }
  .title { font-size:22px; font-weight:600; margin:4px 0 12px; }
  .h1 { font-size:26px; font-weight:700; margin:0 0 10px; }
  label { font-size:13px; font-weight:600; color:var(--muted); display:block; margin-bottom:6px; }
  input[type=text], input[type=number] { width:100%; padding:10px 12px; border:1px solid var(--line); border-radius:10px; font:inherit; outline:none; }
  .btn { padding:10px 14px; border-radius:10px; border:1px solid var(--line); background:#111; color:#fff; cursor:pointer; font-weight:600; }
  .btn.secondary { background:#f5f5f5; color:#111; }
  .flex { display:flex; gap:10px; align-items:center; }
  .muted { color:var(--muted); font-size:13px; }
  .ok { color:var(--ok); }
  .warn { color:var(--warn); }
  .last-refresh { font-size:13px; color:var(--muted); margin-left:8px; }
  table { width:100%; border-collapse:collapse; font-size:14px; }
  th, td { padding:10px; text-align:left; border-top:1px solid var(--line); }
  thead th { background:#f7f7f7; font-size:13px; }
</style>

<script src="https://cdn.jsdelivr.net/npm/luxon@3/build/global/luxon.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
</head>
<body>
  <div class="wrap">
    <div class="flex" style="justify-content:space-between; margin-bottom:12px;">
      <div class="h1">Staging Time & Players</div>
      <div class="muted" id="now"></div>
    </div>

    <!-- Settings -->
    <div class="card"><div class="pad">
      <div class="title">Auto-refresh Settings</div>
      <div class="flex" style="align-items:center; gap:12px;">
        <label for="refreshSec">Auto-refresh (seconds)</label>
        <input type="number" id="refreshSec" value="60" min="5" style="width:100px;" />
        <button class="btn secondary" id="toggleAutoBtn">Auto: ON</button>
        <span class="last-refresh">Last refresh: <span id="lastRefresh">Never</span></span>
      </div>
    </div></div>

    <!-- Data sources -->
    <div class="card" style="margin-top:16px;"><div class="pad">
      <div class="title">1) Data Sources</div>
      <div class="row">
        <div>
          <label>Matches CSV (URL) — optional</label>
          <div class="flex">
            <input type="text" id="matchesUrl" placeholder="https://.../matches.csv" />
            <button class="btn" id="fetchMatchesBtn">Fetch</button>
          </div>
          <div class="muted" style="margin-top:6px;">
            Expected headers (case-insensitive ok): <code>ID</code>, <code>Time</code>, <code>Event</code>,
            <code>Round</code>, <code>Court</code>, <code>Team 1</code>, <code>Team 2</code>, <code>Score</code>,
            <code>Start</code>, <code>Finish</code>.
          </div>
        </div>

        <div>
          <label>Staging Time CSV (URL) — reads A2=Hour, B2=Minute</label>
          <div class="flex">
            <input type="text" id="stagingUrl" />
            <button class="btn" id="fetchStagingBtn">Fetch</button>
          </div>
          <div class="muted" style="margin-top:6px;">
            Builds today’s time in the selected timezone from Hour (0–23) and Minute (0–59).
          </div>
        </div>
      </div>
    </div></div>

    <!-- Staging time + diagnostics -->
    <div class="row" style="margin-top:16px;">
      <div class="card"><div class="pad">
        <div class="title">2) Current Staging Time</div>
        <div style="font-size:22px; font-weight:700; color:#0b7c3e;" id="stagingTimeBig">
          Fetching staging time…
        </div>
        <div class="muted">Timezone:
          <input type="text" id="tz" value="America/Los_Angeles" style="width:220px; margin-left:8px;" />
        </div>
      </div></div>

      <div class="card"><div class="pad">
        <div class="title">3) Diagnostics</div>
        <div>Matches loaded: <span id="diagMatches">0</span></div>
        <div>Currently playing (heuristic): <span id="diagPlaying">0</span></div>
        <div>Staging candidates: <span id="diagCandidates">0</span></div>
        <div>Players to stage (unique): <span id="diagPlayers">0</span></div>
      </div></div>
    </div>

    <!-- Players table -->
    <div class="card" style="margin-top:16px;"><div class="pad">
      <div class="title">4) Players to Stage</div>
      <div class="muted" id="playersEmpty">Load Matches CSV to compute staging players.</div>
      <div style="overflow:auto;">
        <table id="playersTable" style="display:none;">
          <thead>
            <tr>
              <th>Player</th><th>Opponent</th><th>Division</th><th>Round</th><th>Court</th><th>Match ID</th><th>Est. Start</th>
            </tr>
          </thead>
          <tbody id="playersBody"></tbody>
        </table>
      </div>
    </div></div>
  </div>

<script>
(function(){
  const { DateTime } = luxon;

  // Defaults
  const defaultStagingUrl =
    "https://docs.google.com/spreadsheets/d/e/2PACX-1vTCnxXDwQE5lgVWkm51FKG48ZPYtOYYQN4Zj-w1M1j6giv69A_CDSSIZQHTtk0ouVg06xH_uGHa-i5A/pub?gid=0&single=true&output=csv";

  // Elements
  const nowEl = document.getElementById("now");
  const lastRefreshEl = document.getElementById("lastRefresh");
  const refreshSecEl = document.getElementById("refreshSec");
  const toggleAutoBtn = document.getElementById("toggleAutoBtn");
  const matchesUrlEl = document.getElementById("matchesUrl");
  const stagingUrlEl = document.getElementById("stagingUrl");
  const fetchMatchesBtn = document.getElementById("fetchMatchesBtn");
  const fetchStagingBtn = document.getElementById("fetchStagingBtn");
  const stagingTimeBigEl = document.getElementById("stagingTimeBig");
  const tzEl = document.getElementById("tz");
  const diagMatchesEl = document.getElementById("diagMatches");
  const diagPlayingEl = document.getElementById("diagPlaying");
  const diagCandidatesEl = document.getElementById("diagCandidates");
  const diagPlayersEl = document.getElementById("diagPlayers");
  const playersEmptyEl = document.getElementById("playersEmpty");
  const playersTableEl = document.getElementById("playersTable");
  const playersBodyEl = document.getElementById("playersBody");

  // State
  let auto = true;
  let timer = null;
  let zone = tzEl.value;
  let stagingCutoff = null;   // Luxon DateTime
  let matchesRows = [];

  // Clock
  setInterval(() => {
    nowEl.textContent = "Local time: " + DateTime.now().setZone(zone).toFormat("ccc, LLL d, t") + " (" + zone + ")";
  }, 1000);
  function recordRefresh(){
    lastRefreshEl.textContent = DateTime.now().setZone(zone).toFormat("ccc LLL d yyyy t");
  }

  function toKey(s){
    if (!s) return "";
    return String(s).trim().toLowerCase().replace(/[^a-z0-9]+/g,"_").replace(/^_+|_+$/g,"");
  }
  function looksZero(v){
    if (v == null) return true;
    const s = String(v).trim();
    if (!s) return true;
    return /^0+:?0*:?0*(\.0+)?$/.test(s);
  }
  function parseDateAny(s){
    if (!s) return null;
    const str = String(s).trim();
    const d1 = Date.parse(str);
    if (!Number.isNaN(d1)) return DateTime.fromMillis(d1).setZone(zone);
    const fmts = [
      "EEE M/d/yyyy h:mm a", "EEE MM/dd/yyyy h:mm a",
      "M/d/yyyy h:mm a", "MM/dd/yyyy h:mm a",
      "yyyy-MM-dd'T'HH:mmZZ", "yyyy-MM-dd'T'HH:mm:ssZZ",
      "yyyy-MM-dd HH:mm", "yyyy/MM/dd HH:mm"
    ];
    for (const f of fmts){
      const dt = DateTime.fromFormat(str, f, { zone });
      if (dt.isValid) return dt;
    }
    return null;
  }
  function uniqueBy(arr, getKey){
    const seen = new Set(); const out = [];
    for (const it of arr){
      const k = getKey(it);
      if (!seen.has(k)){ seen.add(k); out.push(it); }
    }
    return out;
  }

  async function fetchText(url){
    const r = await fetch(url, { cache: "no-store" });
    if (!r.ok) throw new Error("Fetch failed " + r.status);
    return await r.text();
  }

  // Staging: read A2/B2 (Hour/Minute)
  async function fetchStaging(){
    const url = stagingUrlEl.value.trim();
    if (!url) return;
    try {
      stagingTimeBigEl.textContent = "Fetching staging time…";
      const text = await fetchText(url);

      // header:true path (first row has hour/min columns)
      let hour = null, minute = null;
      let parsed = Papa.parse(text, { header:true, skipEmptyLines:true });
      if (parsed.data && parsed.data.length){
        const first = parsed.data[0];
        const hourKey = Object.keys(first).find(k => /^(hour|h)$/i.test(k)) || Object.keys(first)[0];
        const minuteKey = Object.keys(first).find(k => /^(minute|min|m)$/i.test(k)) || Object.keys(first)[1];
        hour = Number(first[hourKey]);
        minute = Number(first[minuteKey]);
      }
      // fallback: header:false (row 2 = A2/B2)
      if ((hour==null || Number.isNaN(hour) || minute==null || Number.isNaN(minute))){
        const p2 = Papa.parse(text, { header:false, skipEmptyLines:true });
        const rows = p2.data || [];
        if (rows.length >= 2){
          const r = rows[1];
          hour = Number(r[0]);
          minute = Number(r[1]);
        }
      }

      if (Number.isNaN(hour) || Number.isNaN(minute) || hour==null || minute==null){
        stagingCutoff = null;
        stagingTimeBigEl.innerHTML = '<span class="warn">Could not read Hour/Minute from A2/B2.</span>';
        return;
      }

      stagingCutoff = DateTime.now().setZone(zone).set({ hour, minute, second:0, millisecond:0 });
      stagingTimeBigEl.innerHTML = `Current Staging Time: ${stagingCutoff.toFormat("t")} (${zone})`;

      // If matches already loaded, recompute
      computePlayers();
    } catch (e){
      stagingCutoff = null;
      stagingTimeBigEl.innerHTML = '<span class="warn">Fetch failed.</span>';
    }
  }

  // Matches
  async function fetchMatches(){
    const url = matchesUrlEl.value.trim();
    if (!url) return;
    try {
      const text = await fetchText(url);
      const out = Papa.parse(text, { header:true, skipEmptyLines:true });
      const rows = (out.data || []).map(r => {
        const obj = {}; for (const [k,v] of Object.entries(r)) obj[toKey(k)] = v;
        const player_a = obj["team_1"] || obj["player_a"] || obj["player1"] || obj["team1"] || "";
        const player_b = obj["team_2"] || obj["player_b"] || obj["player2"] || obj["team2"] || "";
        const time = obj["time"] || obj["estimated_start"] || obj["est_start"] || "";
        const start = obj["start"];
        const finish = obj["finish"];
        const score = obj["score"] || "";
        const court = obj["court"] || "";
        const division = obj["event"] || obj["division"] || "";
        const round = obj["round"] || "";
        const match_id = obj["id"] || obj["match_id"] || obj["nr"] || "";

        return {
          player_a, player_b,
          timeStr: time, time: parseDateAny(time),
          startStr: start, finishStr: finish,
          score: String(score || "").trim(),
          court: String(court || "").trim(),
          division: String(division || "").trim(),
          round: String(round || "").trim(),
          match_id: String(match_id || "").trim()
        };
      }).filter(r => r.player_a || r.player_b);
      matchesRows = rows;
      diagMatchesEl.textContent = rows.length;
      computePlayers();
    } catch (e){
      matchesRows = [];
      diagMatchesEl.textContent = "0";
      computePlayers();
    }
  }

  // Compute Players to Stage
  function computePlayers(){
    const now = DateTime.now().setZone(zone);

    // Heuristic for "currently playing"
    const playingIds = new Set();
    for (const m of matchesRows){
      const hasCourt = !!m.court;
      const hasScore = !!m.score;
      const startZero = (m.startStr==null) || /^0+:?0*:?0*(\.0+)?$/.test(String(m.startStr).trim());
      if (m.finishStr && String(m.finishStr).trim() && !/^0+:?0*:?0*(\.0+)?$/.test(String(m.finishStr).trim())) continue; // finished
      if (!startZero){ if (!hasScore) { playingIds.add(m.match_id); continue; } }
      if (m.time && m.time <= now.plus({ minutes: 5 }) && hasCourt && !hasScore){ playingIds.add(m.match_id); continue; }
    }
    diagPlayingEl.textContent = playingIds.size;

    // Stage candidates
    let stageCandidates = [];
    if (stagingCutoff){
      for (const m of matchesRows){
        if (!m.time || m.time > stagingCutoff) continue; // later than cutoff
        if (m.score) continue;                            // already finished
        if (playingIds.has(m.match_id)) continue;         // in play
        stageCandidates.push(m);
      }
    }
    diagCandidatesEl.textContent = stageCandidates.length;

    // Expand to per-player rows, remove those already playing elsewhere
    const players = [];
    for (const m of stageCandidates){
      players.push({ player:m.player_a, opponent:m.player_b, m });
      players.push({ player:m.player_b, opponent:m.player_a, m });
    }
    const nowPlayingNames = new Set();
    for (const m of matchesRows){
      if (playingIds.has(m.match_id)){
        if (m.player_a) nowPlayingNames.add(m.player_a.toLowerCase());
        if (m.player_b) nowPlayingNames.add(m.player_b.toLowerCase());
      }
    }
    const cleaned = players.filter(p => p.player && !nowPlayingNames.has(String(p.player).toLowerCase()));

    // Sort by earliest estimated time, unique by player
    cleaned.sort((a,b) => {
      const ta = a.m.time ? a.m.time.toMillis() : Number.MAX_SAFE_INTEGER;
      const tb = b.m.time ? b.m.time.toMillis() : Number.MAX_SAFE_INTEGER;
      return ta - tb;
    });
    const unique = uniqueBy(cleaned, r => String(r.player).toLowerCase());

    // Render
    playersBodyEl.innerHTML = "";
    if (!unique.length){
      playersTableEl.style.display = "none";
      playersEmptyEl.style.display = "block";
      diagPlayersEl.textContent = "0";
      return;
    }
    diagPlayersEl.textContent = String(unique.length);
    playersEmptyEl.style.display = "none";
    playersTableEl.style.display = "table";
    for (const r of unique){
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td><strong>${escapeHtml(r.player)}</strong></td>
        <td>${escapeHtml(r.opponent || "TBD")}</td>
        <td>${escapeHtml(r.m.division || "")}</td>
        <td>${escapeHtml(r.m.round || "")}</td>
        <td>${escapeHtml(r.m.court || "TBD")}</td>
        <td>${escapeHtml(r.m.match_id || "")}</td>
        <td>${r.m.time ? r.m.time.toFormat("t") : "—"}</td>
      `;
      playersBodyEl.appendChild(tr);
    }
  }

  function escapeHtml(s){
    return String(s==null?"":s)
      .replace(/&/g,"&amp;").replace(/</g,"&lt;")
      .replace(/>/g,"&gt;").replace(/\"/g,"&quot;").replace(/'/g,"&#039;");
  }

  // Timer controls
  function startTimer(){
    stopTimer();
    const sec = Math.max(5, Number(refreshSecEl.value || 60));
    timer = setInterval(async () => {
      await fetchStaging();
      if (matchesUrlEl.value.trim()) await fetchMatches();
      recordRefresh();
    }, sec * 1000);
  }
  function stopTimer(){ if (timer){ clearInterval(timer); timer=null; } }

  // Wire UI
  fetchMatchesBtn.addEventListener("click", async () => { await fetchMatches(); recordRefresh(); });
  fetchStagingBtn.addEventListener("click", async () => { await fetchStaging(); recordRefresh(); });
  toggleAutoBtn.addEventListener("click", () => {
    auto = !auto;
    toggleAutoBtn.textContent = "Auto: " + (auto ? "ON" : "OFF");
    if (auto) startTimer(); else stopTimer();
  });
  tzEl.addEventListener("change", () => {
    zone = tzEl.value;
    if (stagingCutoff){
      stagingTimeBigEl.innerHTML = `Current Staging Time: ${stagingCutoff.setZone(zone).toFormat("t")} (${zone})`;
    }
    computePlayers();
  });

  // Init
  stagingUrlEl.value = defaultStagingUrl;
  (async () => {
    await fetchStaging();
    // If you want to auto-load your matches URL by default, set it here:
    // matchesUrlEl.value = "https://.../matches.csv"; await fetchMatches();
    recordRefresh();
    startTimer();
  })();
})();
</script>
</body>
</html>
