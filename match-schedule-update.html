<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Match Schedule Update (Matches Only)</title>
<style>
  body{margin:0;font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:#fafafa;color:#111}
  .wrap{max-width:900px;margin:0 auto;padding:24px}
  .card{background:#fff;border:1px solid #eaeaea;border-radius:14px;box-shadow:0 1px 2px rgba(0,0,0,.04);padding:18px 20px;margin-bottom:18px}
  .title{font-weight:700;font-size:20px;margin-bottom:8px}
  .muted{color:#666;font-size:14px}
  input[type=text]{width:100%;padding:10px 12px;border:1px solid #eaeaea;border-radius:10px;font:inherit}
  .btn{padding:10px 14px;border-radius:10px;border:1px solid #eaeaea;background:#111;color:#fff;font-weight:600;cursor:pointer}
  .ok{color:#0b7c3e}
  .warn{color:#c62828}
  table{width:100%;border-collapse:collapse;font-size:14px}
  th,td{padding:8px;border-top:1px solid #eee;text-align:left}
  thead th{background:#f7f7f7}
  code.inline{background:#f6f6f6;padding:2px 6px;border-radius:6px;border:1px solid #eee}
  .kv{font-size:13px;color:#555}
</style>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
</head>
<body>
<div class="wrap">
  <h1 style="margin:0 0 12px">Match Schedule Update (Matches Only)</h1>

  <div class="card">
    <div class="title">1) Apps Script Web App</div>
    <div class="muted" style="margin-bottom:6px">
      Writes normalized rows to the <b>Matches</b> tab in your sheet
      <span class="inline">staging-time-match-schedule-update</span>.
    </div>
    <input id="endpoint" type="text"
      value="https://script.google.com/macros/s/AKfycbyGK-R4txGHYAZ8cenp7pXDZyzJjlf1uPXY4I0JJk381986X8jclaGUeUZ36a2i_vfe4w/exec"
      readonly />
  </div>

  <div class="card">
    <div class="title">2) Upload Tournament XLSX</div>
    <div class="muted">Pick your tournament export (.xlsx). We’ll detect the real header row, normalize columns, then upload to <b>Matches</b>.</div>
    <input id="xlsxInput" type="file" accept=".xlsx,.XLSX,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" />
    <div style="margin-top:10px">
      <button class="btn" id="sendBtn">Send to Google Sheet</button>
      <span id="status" style="margin-left:10px" class="muted">Idle</span>
    </div>
    <div id="diag" class="kv" style="margin-top:8px"></div>
  </div>

  <div class="card">
    <div class="title">Published Matches CSV (for your public page)</div>
    <div class="muted" style="margin-bottom:8px">
      Used by <b>staging-time-and-players.html</b>:
    </div>
    <input type="text" readonly
      value="https://docs.google.com/spreadsheets/d/e/2PACX-1vSiikhANBenfXD_aaQTFjMPDDozxaPFdn986N9Q9k9AzKD9NycWNblIOcGyNrhRHSIXNkBF4SrLksMU/pub?gid=0&single=true&output=csv" />
    <div class="muted" style="margin-top:8px">
      <a target="_blank" href="https://docs.google.com/spreadsheets/d/e/2PACX-1vSiikhANBenfXD_aaQTFjMPDDozxaPFdn986N9Q9k9AzKD9NycWNblIOcGyNrhRHSIXNkBF4SrLksMU/pub?gid=0&single=true&output=csv">
        Open CSV</a>
      &nbsp;•&nbsp;
      <a target="_blank" href="https://docs.google.com/spreadsheets/d/e/2PACX-1vSiikhANBenfXD_aaQTFjMPDDozxaPFdn986N9Q9k9AzKD9NycWNblIOcGyNrhRHSIXNkBF4SrLksMU/pubhtml?gid=0&single=true">
        HTML View</a>
    </div>
  </div>

  <div class="card">
    <div class="title">Preview (first 20 rows)</div>
    <div class="muted">Schema: <code class="inline">ID</code>, <code class="inline">Time</code>, <code class="inline">Event</code>, <code class="inline">Round</code>, <code class="inline">Court</code>, <code class="inline">Team 1</code>, <code class="inline">Team 2</code>, <code class="inline">Score</code>, <code class="inline">Start</code>, <code class="inline">Finish</code></div>
    <div style="overflow:auto">
      <table>
        <thead><tr id="thead"></tr></thead>
        <tbody id="tbody"></tbody>
      </table>
    </div>
  </div>
</div>

<script>
(function(){
  const endpointEl = document.getElementById('endpoint');
  const xlsxInput = document.getElementById('xlsxInput');
  const sendBtn = document.getElementById('sendBtn');
  const statusEl = document.getElementById('status');
  const theadEl = document.getElementById('thead');
  const tbodyEl = document.getElementById('tbody');
  const diagEl = document.getElementById('diag');

  let normalizedRows = [];
  let lastFile = null;

  function toKey(s){return String(s||'').trim().toLowerCase().replace(/[^a-z0-9]+/g,'_').replace(/^_+|_+$/g,'');}

  function looksLikeHeaderValue(v){
    const s = String(v||'').trim().toLowerCase();
    const keys = ['nr','no','id','time','estimated','event','division','category','round','stage','court','team','player','score','result','start','finish','end'];
    return keys.some(k => s.includes(k));
  }

  function scoreHeaderRow(arr){
    // Score based on how many cells look like header keywords
    let score = 0;
    for (const cell of arr) if (looksLikeHeaderValue(cell)) score++;
    return score;
  }

  function normalizeFromArrays(rows){
    // rows: array of arrays (header:1)
    // Find best header row within first ~30 lines
    const maxScan = Math.min(30, rows.length);
    let best = { idx: -1, score: -1 };
    for (let i=0;i<maxScan;i++){
      const score = scoreHeaderRow(rows[i]||[]);
      if (score > best.score) best = { idx:i, score };
    }
    if (best.idx < 0 || best.score < 2) return { headerIdx: -1, headers: [], rows: [] };

    const headerIdx = best.idx;
    const headersRaw = (rows[headerIdx] || []).map(x => String(x||'').trim());

    // Build objects from subsequent rows until end (ignore fully empty)
    const objs = [];
    for (let r=headerIdx+1;r<rows.length;r++){
      const row = rows[r] || [];
      const allEmpty = row.every(v => (v==='' || v==null));
      if (allEmpty) continue;
      const o = {};
      for (let c=0;c<headersRaw.length;c++){
        const h = headersRaw[c] || '';
        o[h] = row[c] == null ? '' : String(row[c]);
      }
      objs.push(o);
    }

    // Rename columns to normalized schema
    const out = [];
    for (const r of objs){
      const keyed = {}; for (const [k,v] of Object.entries(r)) keyed[toKey(k)] = v;

      const id     = keyed.id || keyed.match_id || keyed.nr || keyed.no || keyed.match || '';
      const time   = keyed.time || keyed.estimated_start || keyed.est_start || keyed.start_time || '';
      const event  = keyed.event || keyed.division || keyed.category || '';
      const round  = keyed.round || keyed.stage || '';
      const court  = keyed.court || keyed.court_name || '';
      const team1  = keyed.team_1 || keyed.team1 || keyed.player_a || keyed.player1 || keyed.home || '';
      const team2  = keyed.team_2 || keyed.team2 || keyed.player_b || keyed.player2 || keyed.away || '';
      const score  = keyed.score || keyed.result || '';
      const start  = keyed.start || keyed.actual_start || '';
      const finish = keyed.finish || keyed.end || '';

      if (String(team1||'').trim() || String(team2||'').trim()){
        out.push({
          "ID":String(id||''),
          "Time":String(time||''),
          "Event":String(event||''),
          "Round":String(round||''),
          "Court":String(court||''),
          "Team 1":String(team1||''),
          "Team 2":String(team2||''),
          "Score":String(score||''),
          "Start":String(start||''),
          "Finish":String(finish||'')
        });
      }
    }
    return { headerIdx, headers: headersRaw, rows: out };
  }

  function renderPreview(rows){
    tbodyEl.innerHTML=''; theadEl.innerHTML='';
    if(!rows.length){ statusEl.innerHTML='<span class="warn">Parsed 0 rows — check file/sheet contents.</span>'; return; }
    const headers=Object.keys(rows[0]);
    for(const h of headers){const th=document.createElement('th');th.textContent=h;theadEl.appendChild(th);}
    for(const r of rows.slice(0,20)){
      const tr=document.createElement('tr');
      tr.innerHTML=headers.map(h=>`<td>${escapeHtml(r[h])}</td>`).join('');
      tbodyEl.appendChild(tr);
    }
    statusEl.innerHTML=`<span class="ok">Parsed ${rows.length} rows.</span>`;
  }

  function escapeHtml(s){return String(s??'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/\"/g,'&quot;').replace(/'/g,'&#039;');}

  async function parseSelectedFileIfNeeded(){
    if (normalizedRows.length > 0) return true;
    const file = xlsxInput.files && xlsxInput.files[0] ? xlsxInput.files[0] : lastFile;
    if (!file) return false;
    lastFile = file;
    try{
      statusEl.textContent='Parsing XLSX…';
      const data = await file.arrayBuffer();
      const wb = XLSX.read(data,{type:'array'});

      let bestSheet = null;
      let bestHeaderIdx = -1;
      let bestScore = -1;
      let bestResult = null;

      for (const name of wb.SheetNames){
        const ws = wb.Sheets[name];
        const rows = XLSX.utils.sheet_to_json(ws,{header:1,defval:''}); // raw rows
        if (!rows || !rows.length) continue;

        // try header detection on this sheet
        const maxScan = Math.min(30, rows.length);
        let localBestIdx = -1, localBestScore = -1;
        for (let i=0;i<maxScan;i++){
          const sc = scoreHeaderRow(rows[i]||[]);
          if (sc > localBestScore){ localBestScore = sc; localBestIdx = i; }
        }
        if (localBestScore < 2) continue;

        // build normalized rows
        const res = normalizeFromArrays(rows);
        if (res.rows.length > 0 && localBestScore >= bestScore){
          bestSheet = name;
          bestHeaderIdx = res.headerIdx;
          bestScore = localBestScore;
          bestResult = res;
        }
      }

      if (!bestResult || !bestResult.rows.length){
        // fallback: simple first non-empty sheet with header objects
        for (const name of wb.SheetNames){
          const ws = wb.Sheets[name];
          const json = XLSX.utils.sheet_to_json(ws,{defval:''});
          if (json.length){
            const out = normalizeFromArrays([Object.keys(json[0])].concat(json.map(obj => Object.values(obj))));
            if (out.rows.length){
              bestSheet = name; bestHeaderIdx = 0; bestResult = out; break;
            }
          }
        }
      }

      if (bestResult && bestResult.rows.length){
        normalizedRows = bestResult.rows;
        renderPreview(normalizedRows);
        diagEl.textContent = `Detected sheet: "${bestSheet}", header row: ${bestHeaderIdx+1}`;
        return true;
      } else {
        normalizedRows = [];
        renderPreview([]);
        diagEl.textContent = `Could not detect a usable header row in any sheet. Try exporting with column headers visible.`;
        return false;
      }
    } catch (err){
      statusEl.innerHTML = `<span class="warn">Parse failed: ${escapeHtml(String(err))}</span>`;
      return false;
    }
  }

  xlsxInput.addEventListener('change', async () => {
    normalizedRows = []; // reset
    await parseSelectedFileIfNeeded();
  });

  sendBtn.addEventListener('click', async () => {
    const endpoint = (endpointEl.value||'').trim();
    if (!endpoint) { alert('Missing Apps Script URL.'); return; }

    const ok = await parseSelectedFileIfNeeded();
    if (!ok) { alert('Could not parse any rows from the XLSX.'); return; }

    const body = { matches: normalizedRows, overwrite: true };

    try{
      statusEl.textContent='Sending to Google Sheet…';
      const r=await fetch(endpoint,{
        method:'POST',
        headers:{'Content-Type':'application/json'},
        body:JSON.stringify(body),
        mode:'cors'
      });
      const j=await r.json();
      if(!j.ok) throw new Error(j.error||'Unknown error');
      statusEl.innerHTML=`<span class="ok">Wrote ${j.rows} rows to Matches.</span>`;
    }catch(err){
      statusEl.innerHTML=`<span class="warn">Upload failed: ${escapeHtml(String(err))}</span>`;
    }
  });
})();
</script>
</body>
</html>
